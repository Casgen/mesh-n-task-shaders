#version 460

#extension GL_EXT_debug_printf : enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout (std430, binding = 0) buffer LODMeshInfo {
    uint index_count[8];
    uint index_offset[8];
    uint vertex_count[8];
	vec3 sphere_pos;
	float sphere_radius;
    uint lod_count;
} lod_mesh_info;

layout (std430, set = 1, binding = 0) buffer Instances {
	mat4 matrices[];
} instances;

struct InstanceInfo {
	uint lod;
	bool is_visible;
};

struct DrawCmd {
	uint index_count;
	uint instance_count;
	uint first_index;
	int vertex_offset;
	uint first_instance;
};

layout (std430, set = 1, binding = 2) buffer IndirectDrawCmds {
	DrawCmd cmds[8];
} draw_cmds;

layout (std430, set = 2, binding = 0) buffer ScratchBuffer {
	InstanceInfo infos[];
} scratch_buffer;

struct Frustum {
	vec3 left;
	vec3 right;
	vec3 top;
	vec3 bottom;
	vec3 front;
	vec3 back;
	vec3 point_sides;
	vec3 point_front;
	vec3 point_back;
	vec3 side_vec;
	float azimuth;
	float zenith;
};

layout (push_constant, std430) uniform LodPC {
    Frustum u_frustum;
	uint u_lod_count;
	uint u_max_instance_count;
	uint u_instance_count;
	float u_lod_pow;
	bool u_enable_culling;
};

bool is_not_clipped(uint instance_index) {

	if (!u_enable_culling) {
		return false;
	}

	vec4 transl_pos = instances.matrices[instance_index] * vec4(lod_mesh_info.sphere_pos, 1.f);
	vec3 sides_vector = transl_pos.xyz - u_frustum.point_sides;

	float left_distance = dot(sides_vector, u_frustum.left) - lod_mesh_info.sphere_radius; 
	float right_distance = dot(sides_vector, u_frustum.right) - lod_mesh_info.sphere_radius; 
	float top_distance = dot(sides_vector, u_frustum.top) - lod_mesh_info.sphere_radius; 
	float bottom_distance = dot(sides_vector, u_frustum.bottom) - lod_mesh_info.sphere_radius; 
	float front_distance = dot(transl_pos.xyz - u_frustum.point_front, u_frustum.front) - lod_mesh_info.sphere_radius; 
	float back_distance = dot(transl_pos.xyz - u_frustum.point_back, u_frustum.back) - lod_mesh_info.sphere_radius; 

	bool is_visible = true;
	is_visible = is_visible && left_distance < 0.f;
	is_visible = is_visible && right_distance < 0.f; 
	is_visible = is_visible && top_distance < 0.f;
	is_visible = is_visible && bottom_distance < 0.f;
	is_visible = is_visible && front_distance < 0.f;
	is_visible = is_visible && back_distance < 0.f;

	return is_visible;
}

uint calculate_lod(uint instance_index) {
	vec3 instance_pos = instances.matrices[instance_index][3].xyz;

	float distance = length(instance_pos - u_frustum.point_sides);
	float lod_f = pow(distance, u_lod_pow);
	
	return uint(clamp(lod_f, 0.f, lod_mesh_info.lod_count - 1));
}

void main() {

	uint instance_id = gl_GlobalInvocationID.x; 

	if (instance_id >= u_instance_count) {
		return;
	}

	uint lod = calculate_lod(instance_id);
	scratch_buffer.infos[instance_id].lod = lod;

	bool is_visible = is_not_clipped(instance_id);
	scratch_buffer.infos[instance_id].is_visible = is_visible;

	atomicAdd(draw_cmds.cmds[lod].instance_count, uint(is_visible));

}
