#version 460

#extension GL_EXT_debug_printf : enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout (std430, binding = 0) buffer LODMeshInfo {
    uint index_count[8];
    uint index_offset[8];
    uint vertex_count[8];
    uint lod_count;
} lod_mesh_info;

layout (std430, set = 1, binding = 0) buffer Instances {
	mat4 matrices[];
} instances;

struct InstanceInfo {
	uint lod;
	uint index;
};

layout (std430, set = 1, binding = 1) buffer InstanceInfos {
	InstanceInfo infos[];
} instance_infos;

struct DrawCmd {
	uint index_count;
	uint instance_count;
	uint first_index;
	int vertex_offset;
	uint first_instance;
};

layout (std430, set = 1, binding = 2) buffer IndirectDrawCmds {
	DrawCmd cmds[8];
} draw_cmds;

layout (std430, set = 2, binding = 0) buffer ScratchBuffer {
	InstanceInfo infos[];
} scratch_buffer;

struct Frustum {
	vec3 left;
	vec3 right;
	vec3 top;
	vec3 bottom;
	vec3 front;
	vec3 back;
	vec3 point_sides;
	vec3 point_front;
	vec3 point_back;
	vec3 side_vec;
	float azimuth;
	float zenith;
};

layout (push_constant, std430) uniform LodPC {
    Frustum u_frustum;
	uint u_lod_count;
	uint u_max_instance_count;
	uint u_instance_count;
	float u_lod_pow;
	uint u_enable_culling;
};

uint calculate_lod(uint instance_index) {
	vec3 instance_pos = instances.matrices[instance_index][3].xyz;

	float distance = length(instance_pos - u_frustum.point_sides);
	float lod_f = pow(distance, u_lod_pow);
	
	return uint(clamp(lod_f, 0.f, lod_mesh_info.lod_count - 1));
}

void main() {

	uint instance_id = gl_GlobalInvocationID.x; 

	if (instance_id >= u_instance_count) {
		return;
	}

	uint lod = calculate_lod(instance_id);
	scratch_buffer.infos[instance_id].lod = lod;

	atomicAdd(draw_cmds.cmds[lod].instance_count, 1);

	memoryBarrierBuffer();
	
	if (instance_id < lod_mesh_info.lod_count && draw_cmds.cmds[instance_id].instance_count > 0) {

		draw_cmds.cmds[instance_id].index_count = lod_mesh_info.index_count[instance_id];
		draw_cmds.cmds[instance_id].first_index = lod_mesh_info.index_offset[instance_id];
		draw_cmds.cmds[instance_id].vertex_offset = 0;
		draw_cmds.cmds[instance_id].first_instance = 0;

		for (uint i = 0; i < instance_id; i++) {
			draw_cmds.cmds[instance_id].first_instance += draw_cmds.cmds[i].instance_count;
		}

		DrawCmd cmd = draw_cmds.cmds[instance_id];

		uint instance_index = cmd.first_instance;
		uint max_offset = cmd.first_instance + cmd.instance_count;

		uint i = 0;

		while (instance_index < max_offset) {
			if (scratch_buffer.infos[i].lod == instance_id) {
				instance_infos.infos[instance_index].index = i;
				instance_infos.infos[instance_index].lod = instance_id;
				instance_index++;
			}

			i++;
		}

	}


}
