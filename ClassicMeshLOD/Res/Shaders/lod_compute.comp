#version 460

#extension GL_EXT_debug_printf : enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


layout (std430, binding = 0) buffer LODMeshInfo {
    uint indexCount[8];
    uint indexOffset[8];
    uint vertexCount[8];
    uint LodCount;
} lod_mesh_info;

layout (std430, set = 1, binding = 0) buffer Instances {
	mat4 matrices[];
} instances;

struct InstanceInfo {
	uint lod;
	uint index;
};

layout (std430, set = 1, binding = 1) buffer InstanceInfos {
	InstanceInfo infos[];
} instance_infos;

struct DrawCmd {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int vertexOffset;
	uint firstInstance;
};

layout (std430, set = 1, binding = 2) buffer IndirectDrawCmds {
	DrawCmd cmds[8];
} draw_cmds;


struct Frustum {
	vec3 left;
	vec3 right;
	vec3 top;
	vec3 bottom;
	vec3 front;
	vec3 back;
	vec3 point_sides;
	vec3 point_front;
	vec3 point_back;
	vec3 side_vec;
	float azimuth;
	float zenith;
};

layout (push_constant, std430) uniform FrustumPC {
    Frustum u_frustum;
	uint u_lod_count;
	uint u_max_instance_count;
	uint u_instance_count;
	float u_lod_pow;
	uint u_enable_culling;
};

uint calculate_lod(uint instance_index) {
	vec3 instance_pos = instances.matrices[instance_index][3].xyz;

	float distance = length(instance_pos - u_frustum.point_sides);
	float lod_f = pow(distance, u_lod_pow);
	
	return uint(clamp(lod_f, 0.f, u_lod_count - 1));
}

void main() {
	
	uint instance_id = gl_GlobalInvocationID.x; 
	
	instance_infos.infos[instance_id].index = instance_id;
	instance_infos.infos[instance_id].lod = calculate_lod(instance_id);

	

}
