#version 460

#extension GL_EXT_mesh_shader : require
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;


struct SharedData
{
	uint meshlet_indices[64];
};

struct Frustum {
	vec3 left;
	vec3 right;
	vec3 top;
	vec3 bottom;
	vec3 front;
	vec3 back;
	vec3 pointSides;
	vec3 pointFront;
	vec3 pointBack;
};

struct s_meshlet_bound {
	vec3 normal;
	float cone_angle;
	vec3 sphere_pos;
	float sphere_radius;
	vec3 normal_pos;
};

layout (binding = 0) uniform MatrixBuffer {
    mat4 model;
    mat4 view;
    mat4 proj;
	Frustum frustum;
} mat_buffer;

layout (std430, set = 1, binding = 4) buffer MeshletBounds {
	s_meshlet_bound bounds[];	
} meshlet_bounds;

shared bool dispatch_bits[64];

taskPayloadSharedEXT SharedData payload;

layout (push_constant, std430) uniform MeshPushConstant {
	// The offset is here due to the offset due to the preceding push constant used
	// in the fragment shader.
    layout(offset = 96) mat4 rotation_mat; 
    mat4 scale_mat;
	uint meshlet_count;
};


void main()
{
	
	// uint u_id = 64 * gl_WorkGroupID.x + gl_LocalInvocationIndex;

	// if (u_id >= meshlet_count) {
	// 	return;
	// }

	// payload.meshlet_indices[gl_LocalInvocationIndex] = u_id;

	// s_meshlet_bound bound = meshlet_bounds.bounds[u_id];


	// vec4 t_sphere_pos = mat_buffer.proj * mat_buffer.view * rotation_mat * scale_mat * vec4(bound.sphere_pos, 1.f);
	// 	
	// bool isNotClipped = -t_sphere_pos.w < t_sphere_pos.x && t_sphere_pos.x < t_sphere_pos.w &&
	// 				 -t_sphere_pos.w < t_sphere_pos.y && t_sphere_pos.y < t_sphere_pos.w &&
	// 				 -t_sphere_pos.w < t_sphere_pos.z && t_sphere_pos.z < t_sphere_pos.w;
	// 
	// dispatch_bits[gl_LocalInvocationIndex] = isNotClipped;



	// if (gl_LocalInvocationIndex == 0) {
	// 	uint accIndex = 0;
	// 	
	// 	for (uint i = 0; i < 64; i++) {
	// 		if (dispatch_bits[i]) {
	// 			payload.meshlet_indices[accIndex++] = payload.meshlet_indices[i];
	// 		}
	// 	}

	// 	uint offset = 64 * (gl_WorkGroupID.x + 1);
	// 	uint min_offset = 64 * gl_WorkGroupID.x;

	// 	uint valid_tasks = min(accIndex, meshlet_count - min_offset);

	// 	EmitMeshTasksEXT(valid_tasks, 1, 1);
	// }

	uint global_id = 64 * gl_WorkGroupID.x + gl_LocalInvocationIndex;
	payload.meshlet_indices[gl_LocalInvocationIndex] = global_id;

	if (gl_LocalInvocationIndex == 0) {
		uint offset = 64 * (gl_WorkGroupID.x + 1);
		uint min_offset = 64 * gl_WorkGroupID.x;
		

		uint valid_tasks = min(offset - min_offset, meshlet_count - min_offset);

		EmitMeshTasksEXT(valid_tasks, 1, 1);
	}
}

